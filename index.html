<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OXGOOSE RADIO</title>

  <style>
    :root { color-scheme: dark; }

    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#05030a;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:#fff;
    }

    /* === STAGE (Scarlett is the UI) === */
    .stage{
      position:relative;
      width:min(900px, 96vw);
      aspect-ratio: 2 / 3; /* portrait poster */
      border-radius: 18px;
      overflow:hidden;
      box-shadow: 0 12px 70px rgba(0,0,0,.75);
      background:#000;
    }

    /* Scarlett image */
    .scarlett{
      position:absolute; inset:0;
      background: url("scarlett-ui.jpg") center/cover no-repeat;
      transform: translateZ(0);
    }

    /* soft vignette + cinematic glaze */
    .glaze{
      position:absolute; inset:0;
      background:
        radial-gradient(circle at 50% 18%, rgba(0,0,0,.12), rgba(0,0,0,.65) 70%, rgba(0,0,0,.85)),
        linear-gradient(0deg, rgba(0,0,0,.25), transparent 30%);
      pointer-events:none;
    }

    /* === INTERACTIVE HOTSPOTS === */
    .hotspots{
      position:absolute; inset:0;
      pointer-events:none; /* hotspots enable their own pointer events */
    }

    .hotspot{
      position:absolute;
      pointer-events:auto;
      border-radius: 14px;
      cursor:pointer;
      user-select:none;

      /* invisible by default, but still clickable */
      background: rgba(255,255,255,0.00);
      outline: none;

      /* subtle always-on aura (barely there) */
      box-shadow: 0 0 0 rgba(0,0,0,0);
      transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
    }

    /* hover glow */
    .hotspot:hover{
      background: rgba(255,255,255,.04);
      box-shadow:
        0 0 18px rgba(255, 60, 220, .22),
        0 0 24px rgba(58, 160, 255, .16);
      transform: scale(1.01);
    }

    /* pressed feedback */
    .hotspot:active{
      transform: scale(0.99);
      background: rgba(255,255,255,.06);
      box-shadow:
        0 0 26px rgba(255, 60, 220, .28),
        0 0 34px rgba(58, 160, 255, .20);
    }

    /* label tooltip (debug) */
    .hotspot .tag{
      display:none;
      position:absolute;
      left: 8px; top: 8px;
      font-size:12px;
      font-weight:900;
      letter-spacing:1px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(0,0,0,.55);
      border: 1px solid rgba(255,255,255,.16);
      backdrop-filter: blur(8px);
      white-space:nowrap;
    }

    /* === SPEAKER PULSE (shoulders) === */
    .speaker{
      position:absolute;
      width: 14%;
      aspect-ratio: 1 / 1;
      border-radius: 999px;
      pointer-events:none;
      opacity: .0; /* off until audio plays */
      transform: translate(-50%, -50%) scale(1);
      filter: blur(.2px);
    }

    .speaker::before{
      content:"";
      position:absolute; inset:-6%;
      border-radius:999px;
      background:
        radial-gradient(circle at 50% 50%, rgba(255,255,255,.16), transparent 45%),
        radial-gradient(circle at 50% 50%, rgba(255, 60, 220, .22), transparent 60%),
        radial-gradient(circle at 50% 50%, rgba(58, 160, 255, .18), transparent 70%);
      opacity:.9;
    }

    .speaker::after{
      content:"";
      position:absolute; inset:8%;
      border-radius:999px;
      border: 1px solid rgba(255,255,255,.12);
      background: radial-gradient(circle at 50% 50%, rgba(0,0,0,.3), rgba(0,0,0,0));
    }

    /* torso visualizer window (optional vibe layer) */
    .visor{
      position:absolute;
      left: 50%;
      top: 54%;
      width: 56%;
      height: 20%;
      transform: translate(-50%, -50%);
      border-radius: 18px;
      pointer-events:none;
      background: rgba(0,0,0,.10);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 0 30px rgba(255,60,220,.10);
      overflow:hidden;
      opacity: .0; /* turns on when playing */
    }
    .bars{
      position:absolute; inset:10% 6%;
      display:flex;
      align-items:flex-end;
      gap:2%;
    }
    .bar{
      flex:1;
      height: 10%;
      border-radius: 10px;
      background: linear-gradient(180deg, rgba(255,60,220,.7), rgba(58,160,255,.55));
      opacity:.85;
      transform: translateZ(0);
    }

    /* === HUD (tiny, non-intrusive) === */
    .hud{
      position:absolute;
      left: 14px;
      bottom: 14px;
      right: 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      pointer-events:none;
      font-size: 12px;
      opacity: .86;
      text-shadow: 0 2px 8px rgba(0,0,0,.55);
    }
    .hud .now{
      pointer-events:none;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      max-width: 70%;
    }
    .hud .meta{
      pointer-events:none;
      font-variant-numeric: tabular-nums;
      white-space:nowrap;
    }

    /* === EDIT MODE (calibrate hotspots) === */
    body.edit .hotspot{
      background: rgba(255,255,255,.06);
      outline: 2px dashed rgba(255,255,255,.35);
      box-shadow: 0 0 0 rgba(0,0,0,0);
    }
    body.edit .hotspot .tag{ display:block; }
    body.edit .speaker,
    body.edit .visor{ opacity: .25; }

    /* resize handle (edit mode) */
    .handle{
      display:none;
      position:absolute;
      width: 14px; height: 14px;
      right: 6px; bottom: 6px;
      border-radius: 4px;
      background: rgba(255,255,255,.55);
      border: 1px solid rgba(0,0,0,.35);
      cursor:nwse-resize;
    }
    body.edit .handle{ display:block; }
  </style>
</head>

<body>
  <div class="stage" id="stage">
    <div class="scarlett"></div>
    <div class="glaze"></div>

    <!-- shoulder speakers (positions are % and can be tweaked) -->
    <div class="speaker" id="spkL" style="left: 28%; top: 22%;"></div>
    <div class="speaker" id="spkR" style="left: 72%; top: 22%;"></div>

    <!-- torso "window" visualizer (position is % and can be tweaked) -->
    <div class="visor" id="visor">
      <div class="bars" id="bars"></div>
    </div>

    <!-- hotspots (invisible clickable UI) -->
    <div class="hotspots" id="hotspots"></div>

    <!-- minimal HUD -->
    <div class="hud">
      <div class="now" id="now">Loading…</div>
      <div class="meta" id="time">0:00 / 0:00</div>
    </div>

    <audio id="audio" preload="metadata"></audio>
  </div>

<script>
(() => {
  // Repo identity
  const OWNER = "OxgooseRadio";
  const REPO  = "Oxgoose-Radio";

  // Image filename in repo root:
  // Upload your art as scarlett-ui.jpg (or change this in CSS above)
  // --------------------------------

  // Edit mode: add ?edit=1 to URL to drag/resize hotspots
  const EDIT = new URLSearchParams(location.search).get("edit") === "1";
  if (EDIT) document.body.classList.add("edit");

  const stage = document.getElementById("stage");
  const hsWrap = document.getElementById("hotspots");
  const nowEl = document.getElementById("now");
  const timeEl = document.getElementById("time");
  const audio = document.getElementById("audio");
  audio.crossOrigin = "anonymous";
  const spkL = document.getElementById("spkL");
  const spkR = document.getElementById("spkR");
  const visor = document.getElementById("visor");
  const barsEl = document.getElementById("bars");

  // --- Build dummy equalizer bars
  const BAR_COUNT = 18;
  const barDivs = [];
  for (let i=0;i<BAR_COUNT;i++){
    const b = document.createElement("div");
    b.className = "bar";
    b.style.height = "12%";
    barsEl.appendChild(b);
    barDivs.push(b);
  }

  // --- Hotspot configuration stored in localStorage
  // Positions are percent of stage: x,y,w,h
const defaultHotspots = [
  { id:"play",    label:"PLAY",    x:24.666666666666664, y:44.96296296296296,  w:11.444444444444445, h:4.555555555555555 },
  { id:"pause",   label:"PAUSE",   x:37.88888888888889,  y:45.851851851851855, w:11.555555555555555, h:4.111111111111111 },
  { id:"next",    label:"NEXT",    x:52.37037037037037,  y:45.307307307307306, w:10.88888888888889,  h:4.185185185185185 },
  { id:"shuffle", label:"SHUFFLE", x:64.44444444444444,  y:44.851851851851855, w:11.666666666666666, h:3.6666666666666665 }
];


  const LS_KEY = "oxgoose_hotspots_v1";
  function loadHotspots(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return DEFAULT_HOTSPOTS;
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed) || !parsed.length) return DEFAULT_HOTSPOTS;
      return parsed;
    }catch{
      return DEFAULT_HOTSPOTS;
    }
  }
  function saveHotspots(list){
    localStorage.setItem(LS_KEY, JSON.stringify(list));
  }

  let hotspots = loadHotspots();

  // --- Track loading (auto from GitHub)
  let tracks = [];
  let current = 0;
  let shuffleOn = true;

  function prettyName(filename){
    return filename
      .replace(/\.mp3$/i, "")
      .replace(/\s*\[OXGOOSE RADIO\]\s*$/i, "")
      .trim();
  }

  function fmtTime(sec){
    if (!isFinite(sec)) return "0:00";
    sec = Math.floor(sec);
    const m = Math.floor(sec/60);
    const s = sec % 60;
    return `${m}:${String(s).padStart(2,"0")}`;
  }

  function setNow(text){ nowEl.textContent = text; }

  function load(i){
    if (!tracks.length) return;
    current = (i + tracks.length) % tracks.length;
    audio.src = tracks[current].url;
    setNow(`Queued: ${prettyName(tracks[current].name)}`);
  }

  async function fetchTracks(){
    const api = `https://api.github.com/repos/${OWNER}/${REPO}/contents/`;
    const r = await fetch(api, { headers: { "Accept": "application/vnd.github+json" } });
    if (!r.ok) throw new Error(`GitHub API error: ${r.status}`);
    const data = await r.json();
    return data
      .filter(x => x.type === "file" && /\.mp3$/i.test(x.name))
      .map(x => ({ name: x.name, url: encodeURI(x.name) }))
      .sort((a,b) => a.name.localeCompare(b.name));
  }

  function play(){
    if (!tracks.length) return;
    if (!audio.src) load(current);
    audio.play().then(() => {
      setNow(`Now Playing: ${prettyName(tracks[current].name)}`);
      spkL.style.opacity = "1";
      spkR.style.opacity = "1";
      visor.style.opacity = ".9";
      startAudioViz();
    }).catch(() => {
      setNow("Click again (browser blocked autoplay).");
    });
  }

  function pause(){
    audio.pause();
    if (tracks.length) setNow(`Paused: ${prettyName(tracks[current].name)}`);
  }

  function next(){
    if (!tracks.length) return;
    if (shuffleOn){
      load(Math.floor(Math.random()*tracks.length));
    } else {
      load(current + 1);
    }
    play();
  }

  function toggleShuffle(){
    shuffleOn = !shuffleOn;
    setNow(`Shuffle: ${shuffleOn ? "On" : "Off"} · ${tracks.length ? prettyName(tracks[current].name) : ""}`);
  }

  // --- Hotspot renderer + editor
  function applyBox(el, box){
    el.style.left = box.x + "%";
    el.style.top  = box.y + "%";
    el.style.width  = box.w + "%";
    el.style.height = box.h + "%";
  }

  function renderHotspots(){
    hsWrap.innerHTML = "";
    hotspots.forEach((h) => {
      const el = document.createElement("div");
      el.className = "hotspot";
      el.dataset.id = h.id;
      applyBox(el, h);

      const tag = document.createElement("div");
      tag.className = "tag";
      tag.textContent = h.label;
      el.appendChild(tag);

      const handle = document.createElement("div");
      handle.className = "handle";
      el.appendChild(handle);

      // click actions
      el.addEventListener("click", (e) => {
        if (EDIT) return;
        switch(h.id){
          case "play": play(); break;
          case "pause": pause(); break;
          case "next": next(); break;
          case "shuffle": toggleShuffle(); break;
        }
      });

      // edit: drag / resize
      if (EDIT){
        makeDraggableResizable(el, handle, h);
      }

      hsWrap.appendChild(el);
    });
  }

  function stageRect(){ return stage.getBoundingClientRect(); }
  function toPct(dx, dy){
    const r = stageRect();
    return { px: (dx / r.width) * 100, py: (dy / r.height) * 100 };
  }

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function makeDraggableResizable(el, handle, model){
    let mode = null; // "drag" or "resize"
    let start = null;

    el.addEventListener("pointerdown", (e) => {
      if (e.target === handle) return;
      mode = "drag";
      start = { x:e.clientX, y:e.clientY, ox:model.x, oy:model.y };
      el.setPointerCapture(e.pointerId);
    });

    handle.addEventListener("pointerdown", (e) => {
      mode = "resize";
      start = { x:e.clientX, y:e.clientY, ow:model.w, oh:model.h };
      el.setPointerCapture(e.pointerId);
      e.stopPropagation();
    });

    el.addEventListener("pointermove", (e) => {
      if (!mode || !start) return;
      const d = toPct(e.clientX - start.x, e.clientY - start.y);

      if (mode === "drag"){
        model.x = clamp(start.ox + d.px, 0, 100 - model.w);
        model.y = clamp(start.oy + d.py, 0, 100 - model.h);
        applyBox(el, model);
      }

      if (mode === "resize"){
        model.w = clamp(start.ow + d.px, 3, 100 - model.x);
        model.h = clamp(start.oh + d.py, 3, 100 - model.y);
        applyBox(el, model);
      }
    });

    el.addEventListener("pointerup", () => {
      if (!mode) return;
      mode = null; start = null;
      saveHotspots(hotspots);
      console.log("Hotspots saved:", hotspots);
    });
  }

  // --- Audio visualization (speaker pulse + equalizer)
  let ctx = null, analyser = null, data = null, raf = null, srcNode = null;

  function startAudioViz(){
    if (ctx && ctx.state === "suspended") ctx.resume().catch(()=>{});
    if (ctx) return;

    ctx = new (window.AudioContext || window.webkitAudioContext)();
    analyser = ctx.createAnalyser();
    analyser.fftSize = 256;
    data = new Uint8Array(analyser.frequencyBinCount);

    srcNode = ctx.createMediaElementSource(audio);
    srcNode.connect(analyser);
    analyser.connect(ctx.destination);

    const tick = () => {
      analyser.getByteFrequencyData(data);

      // average energy for speaker pulse
      let sum = 0;
      for (let i=0;i<data.length;i++) sum += data[i];
      const avg = sum / data.length;            // 0..255
      const n = avg / 255;                      // 0..1

      // Speaker scale pulse
      const s = 0.92 + (n * 0.25);
      spkL.style.transform = `translate(-50%, -50%) scale(${s})`;
      spkR.style.transform = `translate(-50%, -50%) scale(${s})`;
      spkL.style.opacity = String(0.35 + n * 0.65);
      spkR.style.opacity = String(0.35 + n * 0.65);

      // Equalizer bars
      for (let i=0;i<barDivs.length;i++){
        const idx = Math.floor((i / barDivs.length) * data.length);
        const v = data[idx] / 255; // 0..1
        barDivs[i].style.height = `${12 + v * 88}%`;
      }

      raf = requestAnimationFrame(tick);
    };

    raf = requestAnimationFrame(tick);
  }

  audio.addEventListener("timeupdate", () => {
    const d = audio.duration || 0;
    const c = audio.currentTime || 0;
    timeEl.textContent = `${fmtTime(c)} / ${fmtTime(d)}`;
  });

  audio.addEventListener("ended", next);

  // --- init
  (async () => {
    renderHotspots();
    try{
      tracks = await fetchTracks();
      if (!tracks.length){
        setNow("No MP3 files found in repo root.");
        return;
      }
      load(0);
      setNow(`Ready: ${tracks.length} tracks. Click PLAY.`);
    } catch(e){
      console.error(e);
      setNow("Failed to load tracks (GitHub API limit or network). Refresh later.");
    }
  })();

})();
</script>
</body>
</html>
